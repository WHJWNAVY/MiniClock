C51 COMPILER V9.59.0.0   DRV_KEY                                                           05/06/2019 23:08:40 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DRV_KEY
OBJECT MODULE PLACED IN .\Objects\drv_key.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\drv_key.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src) DEBUG PRINT(.\Lis
                    -tings\drv_key.lst) TABS(2) OBJECT(.\Objects\drv_key.obj)

line level    source

   1          #include "drv_key.h"
   2          
   3          sbit KEY_BTN_0 = P1 ^ 1;
   4          sbit KEY_BTN_1 = P1 ^ 0;
   5          sbit KEY_BTN_2 = P3 ^ 7;
   6          
   7          #define KEY_BTN_SHORT_PRESS_CNT  (10u)
   8          #define KEY_BTN_LONG_PRESS_CNT   (1000u)
   9          #define KEY_BTN_LLONG_PRESS_CNT  (5000u)
  10          
  11          uint8 g_key_code = 0;
  12          uint8 g_key_miiror = 0;
  13          
  14          void timer1_init(void)    //1毫秒@27MHz
  15          {
  16   1          AUXR |= 0x40;       //定时器时钟1T模式
  17   1        TMOD &= 0x0F;       //设置定时器模式
  18   1          TMOD |= 0x10;       //设置定时器模式
  19   1          TL1 = 0x88;         //设置定时初值
  20   1          TH1 = 0x96;         //设置定时初值
  21   1          TF1 = 0;        //清除TF1标志
  22   1          ET1 = 1;            //使能定时器0中断
  23   1          EA  = 1;            //使能总中断
  24   1          TR1 = 1;            //定时器1开始计时
  25   1      }
  26          
  27          void key_timer1(void) interrupt 3
  28          {
  29   1          static uint16 key_0_tmr = 0;
  30   1          static uint16 key_1_tmr = 0;
  31   1          static uint16 key_2_tmr = 0;
  32   1      
  33   1          TL1 = 0x88;           //设置定时初值
  34   1          TH1 = 0x96;           //设置定时初值
  35   1          TF1 = 0;            //清除TF1标志
  36   1      
  37   1          if(g_key_code == 0)
  38   1          {
  39   2              if(KEY_BTN_0 == 0)
  40   2              {
  41   3                  key_0_tmr++;
  42   3              }
  43   2              else
  44   2              {
  45   3                  if(key_0_tmr > KEY_BTN_LLONG_PRESS_CNT)
  46   3                  {
  47   4                      g_key_code = (g_key_miiror ? KEY_BTN_DWN_LLP : KEY_BTN_SET_LLP);
  48   4                  }
  49   3                  else if(key_0_tmr > KEY_BTN_LONG_PRESS_CNT)
  50   3                  {
  51   4                      g_key_code = (g_key_miiror ? KEY_BTN_DWN_LP : KEY_BTN_SET_LP);
  52   4                  }
  53   3                  else if(key_0_tmr > KEY_BTN_SHORT_PRESS_CNT)
  54   3                  {
C51 COMPILER V9.59.0.0   DRV_KEY                                                           05/06/2019 23:08:40 PAGE 2   

  55   4                      g_key_code = (g_key_miiror ? KEY_BTN_DWN : KEY_BTN_SET);
  56   4                  }
  57   3      
  58   3                  key_0_tmr = 0;
  59   3              }
  60   2      
  61   2              if(KEY_BTN_1 == 0)
  62   2              {
  63   3                  key_1_tmr++;
  64   3              }
  65   2              else
  66   2              {
  67   3                  if(key_1_tmr > KEY_BTN_LLONG_PRESS_CNT)
  68   3                  {
  69   4                      g_key_code = KEY_BTN_UP_LLP;
  70   4                  }
  71   3                  else if(key_1_tmr > KEY_BTN_LONG_PRESS_CNT)
  72   3                  {
  73   4                      g_key_code = KEY_BTN_UP_LP;
  74   4                  }
  75   3                  else if(key_1_tmr > KEY_BTN_SHORT_PRESS_CNT)
  76   3                  {
  77   4                      g_key_code = KEY_BTN_UP;
  78   4                  }
  79   3      
  80   3                  key_1_tmr = 0;
  81   3              }
  82   2      
  83   2              if(KEY_BTN_2 == 0)
  84   2              {
  85   3                  key_2_tmr++;
  86   3              }
  87   2              else
  88   2              {
  89   3                  if(key_2_tmr > KEY_BTN_LLONG_PRESS_CNT)
  90   3                  {
  91   4                      g_key_code = (g_key_miiror ? KEY_BTN_SET_LLP : KEY_BTN_DWN_LLP);
  92   4                  }
  93   3                  else if(key_2_tmr > KEY_BTN_LONG_PRESS_CNT)
  94   3                  {
  95   4                      g_key_code = (g_key_miiror ? KEY_BTN_SET_LP : KEY_BTN_DWN_LP);
  96   4                  }
  97   3                  else if(key_2_tmr > KEY_BTN_SHORT_PRESS_CNT)
  98   3                  {
  99   4                      g_key_code = (g_key_miiror ? KEY_BTN_SET : KEY_BTN_DWN);
 100   4                  }
 101   3      
 102   3                  key_2_tmr = 0;
 103   3              }
 104   2          }
 105   1          else
 106   1          {
 107   2              key_0_tmr = 0;
 108   2              key_1_tmr = 0;
 109   2              key_2_tmr = 0;
 110   2          }
 111   1      }
 112          
 113          void key_init(void)
 114          {
 115   1          g_key_code = 0;
 116   1          g_key_miiror = 0;
C51 COMPILER V9.59.0.0   DRV_KEY                                                           05/06/2019 23:08:40 PAGE 3   

 117   1          timer1_init();
 118   1      }
 119          
 120          uchar key_get_code(void)
 121          {
 122   1          uint8 keycode = 0;
 123   1      
 124   1          if((g_key_code == KEY_BTN_SET) || (g_key_code == KEY_BTN_SET_LP) || (g_key_code == KEY_BTN_SET_LLP) ||
             - 
 125   1             (g_key_code == KEY_BTN_UP) || (g_key_code == KEY_BTN_UP_LP) || (g_key_code == KEY_BTN_UP_LLP) || 
 126   1             (g_key_code == KEY_BTN_DWN) || (g_key_code == KEY_BTN_DWN_LP) || (g_key_code == KEY_BTN_DWN_LLP))
 127   1          {
 128   2              keycode = g_key_code;
 129   2          }
 130   1          else
 131   1          {
 132   2              keycode = 0;
 133   2          }
 134   1      
 135   1          g_key_code = 0;
 136   1      
 137   1          return keycode;
 138   1      }
 139          
 140          void key_set_mirror(uint8 mirror)
 141          {
 142   1          g_key_miiror = ((mirror) ? 1 : 0);
 143   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    384    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
