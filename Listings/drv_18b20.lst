C51 COMPILER V9.59.0.0   DRV_18B20                                                         05/06/2019 23:08:41 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DRV_18B20
OBJECT MODULE PLACED IN .\Objects\drv_18b20.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\drv_18b20.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src) DEBUG PRINT(.\L
                    -istings\drv_18b20.lst) TABS(2) OBJECT(.\Objects\drv_18b20.obj)

line level    source

   1          #include "drv_18b20.h"
   2          
   3          sbit PIN_DQ = P3 ^ 6;
   4          
   5          void delay_2us() // @24MHz
   6          {
   7   1        uchar i = 0;
   8   1      
   9   1        i = 14;
  10   1        while (--i);
  11   1      }
  12          
  13          void delay_10us() // @24MHz
  14          {
  15   1        uchar i = 0;
  16   1      
  17   1        i = 78;
  18   1        while (--i);
  19   1      }
  20          
  21          void delay_60us() // @24MHz
  22          {
  23   1        uchar i = 0, j = 0;
  24   1      
  25   1        _nop_();
  26   1        i = 2;
  27   1        j = 220;
  28   1        do
  29   1        {
  30   2          while (--j);
  31   2        } while (--i);
  32   1      }
  33          
  34          void delay_80us() // @24MHz
  35          {
  36   1        uchar i = 0, j = 0;
  37   1      
  38   1        _nop_();
  39   1        _nop_();
  40   1        i = 3;
  41   1        j = 123;
  42   1        do
  43   1        {
  44   2          while (--j);
  45   2        } while (--i);
  46   1      }
  47          
  48          void delay_500us() // @24MHz
  49          {
  50   1        uchar i = 0, j = 0;
  51   1      
  52   1        i = 16;
  53   1        j = 147;
  54   1        do
C51 COMPILER V9.59.0.0   DRV_18B20                                                         05/06/2019 23:08:41 PAGE 2   

  55   1        {
  56   2          while (--j);
  57   2        } while (--i);
  58   1      }
  59          
  60          uint8 ds18b20_reset()
  61          {
  62   1          uint8 ret;
  63   1          PIN_DQ = 1;
  64   1          PIN_DQ = 0;
  65   1          delay_500us(); //复位脉冲
  66   1      
  67   1          PIN_DQ = 1;
  68   1          delay_80us();  //等待ds18b20回应
  69   1          ret = (PIN_DQ) ? 1 : 0;
  70   1          delay_500us();
  71   1      
  72   1          return ret;
  73   1      }
  74          
  75          void ds18b20_wrbit(bit b)
  76          {
  77   1          PIN_DQ = 0;
  78   1          delay_10us();
  79   1      
  80   1          PIN_DQ = b;
  81   1          delay_60us();
  82   1      
  83   1          PIN_DQ = 1;
  84   1          delay_2us();
  85   1      }
  86          
  87          void ds_18b20_wrbyte(uint8 byte)
  88          {
  89   1          uint8 i;
  90   1          for(i = 1; i != 0; i <<= 1)
  91   1          {
  92   2              if(i & byte)
  93   2                  ds18b20_wrbit(1);
  94   2              else
  95   2                  ds18b20_wrbit(0);
  96   2          }
  97   1      }
  98          
  99          bit ds18b20_rdbit()
 100          {
 101   1          bit b;
 102   1          PIN_DQ = 0;
 103   1          delay_10us();
 104   1      
 105   1          PIN_DQ = 1;
 106   1          delay_2us();
 107   1      
 108   1          b = PIN_DQ;
 109   1          delay_60us();
 110   1          return b;
 111   1      }
 112          
 113          uint8 ds18b20_rdbyte()
 114          {
 115   1          uint8 i = 0, tmp = 0;
 116   1      
C51 COMPILER V9.59.0.0   DRV_18B20                                                         05/06/2019 23:08:41 PAGE 3   

 117   1          for(i = 1; i != 0; i <<= 1)
 118   1          {
 119   2              if(ds18b20_rdbit())
 120   2                  tmp |= i;
 121   2          }
 122   1      
 123   1          return tmp;
 124   1      }
 125          
 126          #if 0
              uint8 ds18b20_convert(uint16* temp)
              {
                  static uint8 fg=0;  //温度状态
                  if(fg == 0)
                  {
                      if(ds18b20_reset())
                          return RTN_ERR;
                      ds_18b20_wrbyte(0xCC); //跳过ROM匹配
                      ds_18b20_wrbyte(0x44); //启动温度转换
                      fg =1;
                  }
                  else if(PIN_DQ) //总线为高说明温度转换结束
                  {
                      ds18b20_reset();
                      ds_18b20_wrbyte(0xCC); //跳过ROM匹配
                      ds_18b20_wrbyte(0xBE); //读暂存器，读温度
              
                      *temp = ds18b20_rdbyte();  //获取两个字节的温度数字量
                      *temp |= (ds18b20_rdbyte() << 8);
                      fg =0;
                  }
              
                  return RTN_OK;
              }
              #else
 152          uint8 ds18b20_convert(uint8* tmph, uint8* tmpl)
 153          {
 154   1          static uint8 fg = 0; //温度状态
 155   1          if(fg == 0)
 156   1          {
 157   2              if(ds18b20_reset())
 158   2                  return RTN_ERR;
 159   2              ds_18b20_wrbyte(0xCC); //跳过ROM匹配
 160   2              ds_18b20_wrbyte(0x44); //启动温度转换
 161   2              fg = 1;
 162   2          }
 163   1          else if(PIN_DQ) //总线为高说明温度转换结束
 164   1          {
 165   2              ds18b20_reset();
 166   2              ds_18b20_wrbyte(0xCC); //跳过ROM匹配
 167   2              ds_18b20_wrbyte(0xBE); //读暂存器，读温度
 168   2      
 169   2              *tmpl = ds18b20_rdbyte(); //获取两个字节的温度数字量
 170   2              *tmph = ds18b20_rdbyte();
 171   2              fg = 0;
 172   2          }
 173   1      
 174   1          return RTN_OK;
 175   1      }
 176          
 177          uint8 ds18b20_get_temp(uint8* sign, uint16* interger, uint16* decimal)
 178          {
C51 COMPILER V9.59.0.0   DRV_18B20                                                         05/06/2019 23:08:41 PAGE 4   

 179   1          uint16 xdata temp = 0;
 180   1          uint8 xdata templ = 0;
 181   1          uint8 xdata temph = 0;
 182   1      
 183   1          if(ds18b20_convert(&temph, &templ) != RTN_OK)
 184   1          {
 185   2              return RTN_ERR;
 186   2          }
 187   1      
 188   1          if((temph == 0) && (templ == 0))
 189   1          {
 190   2              return RTN_ERR;
 191   2          }
 192   1      
 193   1          temp = ((temph << 8) | templ);
 194   1      
 195   1          if(temph & 0x80)    //如果高位为1说明是负温度
 196   1          {
 197   2              *sign = 1;              //符号部分
 198   2            temp = ~temp;
 199   2              temp++;
 200   2          }
 201   1          else
 202   1          {
 203   2              *sign = 0; 
 204   2          }
 205   1      
 206   1          *interger = ((temp >> 4) & 0xFFu);          //整数部分,两位
 207   1          *decimal = (((temp & 0x0Fu) * 625) / 1000); //小数部分,一位
 208   1      
 209   1          return RTN_OK;
 210   1      }
 211          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    437    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
