C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DRV_LED
OBJECT MODULE PLACED IN .\Objects\drv_led.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\drv_led.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src) DEBUG PRINT(.\Lis
                    -tings\drv_led.lst) TABS(2) OBJECT(.\Objects\drv_led.obj)

line level    source

   1          #include "drv_led.h"
   2          
   3          sbit LED_CLK        = P1 ^ 2;
   4          sbit LED_CS         = P1 ^ 3;
   5          sbit LED_DIN        = P1 ^ 4;
   6          
   7          #define MAX7219_ADDR_NONE           (0x00)
   8          #define MAX7219_ADDR_DIG0           (0x01)
   9          #define MAX7219_ADDR_DIG1           (0x02)
  10          #define MAX7219_ADDR_DIG2           (0x03)
  11          #define MAX7219_ADDR_DIG3           (0x04)
  12          #define MAX7219_ADDR_DIG4           (0x05)
  13          #define MAX7219_ADDR_DIG5           (0x06)
  14          #define MAX7219_ADDR_DIG6           (0x07)
  15          #define MAX7219_ADDR_DIG7           (0x08)
  16          #define MAX7219_ADDR_DECODE_MODE    (0x09)//解码模式
  17          #define MAX7219_ADDR_INTENSITY      (0x0A)//亮度设置
  18          #define MAX7219_ADDR_SCAN_LIMIT     (0x0B)//扫描限位
  19          #define MAX7219_ADDR_SHUTDOWN       (0x0C)//关闭显示
  20          #define MAX7219_ADDR_DISPTEST       (0x0F)//测试模式
  21          
  22          #define MAX7219_DECODE_MODE_NONE    (0x00)//不解码
  23          #define MAX7219_DECODE_MODE_DIG0    (0x01)//解码位0
  24          #define MAX7219_DECODE_MODE_0_3     (0x0F)//解码位0-3
  25          #define MAX7219_DECODE_MODE_0_7     (0xFF)//解码位0-7
  26          
  27          #define MAX7219_SCAN_LIMIT_MAX      (LED_POS_MAX - 1)//只扫描前四个
  28          
  29          #define LED_SEG_NUM_HEX_MAX         (0xFFFFu)
  30          #define LED_SEG_NUM_OCT_MAX         (9999u)
  31          
  32          static uchar g_led_mirror = 0;
  33          uchar LED_DISP_MEM[LED_POS_MAX] = {0};
  34          uint16 LED_FLASH_TMR[LED_POS_MAX] = {0};//闪烁
  35          
  36          #define LED_MIRROR_POS(pos) (pos = (g_led_mirror ? (LED_POS_MAX - 1 - pos) : pos))
  37          #define LED_MIRROR_SEG(seg) (seg = (g_led_mirror ? LED_SEGB_MIRROR[seg] : seg))
  38          
  39          uchar code LED_SEGB_MIRROR[LED_SEGB_MAX] = 
  40          {
  41              LED_SEGB_G,
  42              LED_SEGB_C,
  43              LED_SEGB_B,
  44              LED_SEGB_A,
  45              LED_SEGB_F,
  46              LED_SEGB_E,
  47              LED_SEGB_D,
  48              LED_SEGB_DP
  49          };
  50          
  51          #define u8bset  LED_SEGB_SET
  52          #define _sa    LED_SEGB_A
  53          #define _sb    LED_SEGB_B
  54          #define _sc    LED_SEGB_C
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 2   

  55          #define _sd    LED_SEGB_D
  56          #define _se    LED_SEGB_E
  57          #define _sf    LED_SEGB_F
  58          #define _sg    LED_SEGB_G
  59          #define _sp    LED_SEGB_DP
  60          
  61          
  62          uchar code LED_SEG_CODE[LED_SEG_MAX] =
  63          {
  64              u8bset(_sa)|u8bset(_sb)|u8bset(_sc)|u8bset(_sd)|u8bset(_se)|u8bset(_sf),            //0x7E,// 0
  65              u8bset(_sb)|u8bset(_sc),                                                            //0x30,// 1 |
  66              u8bset(_sa)|u8bset(_sb)|u8bset(_sg)|u8bset(_se)|u8bset(_sd),                        //0x6D,// 2
  67              u8bset(_sa)|u8bset(_sb)|u8bset(_sg)|u8bset(_sc)|u8bset(_sd),                        //0x79,// 3
  68              u8bset(_sf)|u8bset(_sg)|u8bset(_sb)|u8bset(_sc),                                    //0x33,// 4
  69              u8bset(_sa)|u8bset(_sf)|u8bset(_sg)|u8bset(_sc)|u8bset(_sd),                        //0x5B,// 5
  70              u8bset(_sa)|u8bset(_sf)|u8bset(_se)|u8bset(_sd)|u8bset(_sc)|u8bset(_sg),            //0x5F,// 6
  71              u8bset(_sa)|u8bset(_sb)|u8bset(_sc),                                                //0x70,// 7
  72              u8bset(_sa)|u8bset(_sb)|u8bset(_sc)|u8bset(_sd)|u8bset(_se)|u8bset(_sf)|u8bset(_sg),//0x7F,// 8
  73              u8bset(_sa)|u8bset(_sf)|u8bset(_sg)|u8bset(_sb)|u8bset(_sc)|u8bset(_sd),            //0x7B,// 9
  74              u8bset(_sa)|u8bset(_sf)|u8bset(_se)|u8bset(_sb)|u8bset(_sc)|u8bset(_sg),            //0x77,// A
  75              u8bset(_sf)|u8bset(_se)|u8bset(_sd)|u8bset(_sc)|u8bset(_sg),                        //0x1F,// b
  76              u8bset(_sa)|u8bset(_sf)|u8bset(_se)|u8bset(_sd),                                    //0x4E,// C [
  77              u8bset(_sb)|u8bset(_sc)|u8bset(_sd)|u8bset(_se)|u8bset(_sg),                        //0x3D,// d
  78              u8bset(_sa)|u8bset(_sf)|u8bset(_se)|u8bset(_sd)|u8bset(_sg),                        //0x4F,// E
  79              u8bset(_sa)|u8bset(_sf)|u8bset(_se)|u8bset(_sg),                                    //0x47,// F
  80              u8bset(_sa)|u8bset(_sf)|u8bset(_se)|u8bset(_sd)|u8bset(_sc),                        //0x5E,// G
  81              u8bset(_sa)|u8bset(_sb)|u8bset(_sc)|u8bset(_sd),                                    //0x78,// ]
  82              u8bset(_sf)|u8bset(_se)|u8bset(_sc)|u8bset(_sb)|u8bset(_sg),                        //0x37,// H
  83              u8bset(_sf)|u8bset(_se)|u8bset(_sc)|u8bset(_sg),                                    //0x17,// h
  84              u8bset(_sg)|u8bset(_se)|u8bset(_sd),                                                //0x0D,// c
  85              u8bset(_sf)|u8bset(_se)|u8bset(_sd),                                                //0x0E,// L
  86              u8bset(_sa)|u8bset(_sb)|u8bset(_sg)|u8bset(_sf)|u8bset(_se),                        //0x67,// P
  87              u8bset(_sg)|u8bset(_sc)|u8bset(_sd)|u8bset(_se),                                    //0x1D,// o
  88              u8bset(_sa)|u8bset(_sf),                                                            //0x42,//AF
  89              u8bset(_sa)|u8bset(_sb),                                                            //0x60,//AB
  90              u8bset(_sd)|u8bset(_se),                                                            //0x0C,//DE
  91              u8bset(_sc)|u8bset(_sd),                                                            //0x18,//CD
  92              u8bset(_sb)|u8bset(_sc)|u8bset(_sg),                                                //0x31,//BCG
  93              u8bset(_se)|u8bset(_sf)|u8bset(_sg),                                                //0x07,//EFG
  94              u8bset(_sp),                                                                        //0x80,// DP段
  95              u8bset(_sa),                                                                        //0x40,// A段
  96              u8bset(_sb),                                                                        //0x20,// B段
  97              u8bset(_sc),                                                                        //0x10,// C段
  98              u8bset(_sd),                                                                        //0x08,// D段
  99              u8bset(_se),                                                                        //0x04,// E段
 100              u8bset(_sf),                                                                        //0x02,// F段
 101              u8bset(_sg),                                                                        //0x01,// G段 -
 102              0x00,                                                                               // Space
 103          };
 104          
 105          void max7219_writeb(uchar dat)
 106          {
 107   1          uchar i;
 108   1          //LED_CS = 0;
 109   1          for(i = 8; i >= 1; i--)
 110   1          {
 111   2              LED_CLK = 0;
 112   2              LED_DIN = ((dat & 0x80) ? 0xFF : 0x00);
 113   2              dat = dat << 1;
 114   2              LED_CLK = 1;
 115   2          }
 116   1          //LED_CS = 1;
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 3   

 117   1      }
 118          
 119          void max7219_write(uchar add, uchar dat)
 120          {
 121   1          uchar i = 0;
 122   1          LED_CS = 0;
 123   1          _nop_();
 124   1          max7219_writeb(add);
 125   1          _nop_();
 126   1          max7219_writeb(dat);
 127   1          _nop_();
 128   1          LED_CS = 1;
 129   1      }
 130          
 131          void max7219_init(void)
 132          {
 133   1          max7219_write(MAX7219_ADDR_DECODE_MODE, MAX7219_DECODE_MODE_NONE);
 134   1          max7219_write(MAX7219_ADDR_INTENSITY,   LED_MAX_LIGHT);
 135   1          max7219_write(MAX7219_ADDR_SCAN_LIMIT,  MAX7219_SCAN_LIMIT_MAX);//Display digits 0 1 2 3
 136   1          max7219_write(MAX7219_ADDR_SHUTDOWN,    0x01);
 137   1          max7219_write(MAX7219_ADDR_DISPTEST,    0x00);
 138   1      }
 139          
 140          typedef enum led_open_e
 141          {
 142              LED_OPEN_NULL = 0,
 143              LED_OPEN_TRUE,
 144              LED_OPEN_FALSE,
 145          } led_open_t;
 146          
 147          uint8 g_led_open = LED_OPEN_NULL;
 148          
 149          void led_open(void)
 150          {
 151   1          if(g_led_open != LED_OPEN_TRUE)
 152   1          {
 153   2              max7219_write(MAX7219_ADDR_SHUTDOWN, 0x01);//正常模式(掉电模式关)
 154   2              g_led_open = LED_OPEN_TRUE;
 155   2          }
 156   1      }
 157          
 158          void led_close(void)
 159          {
 160   1          if(g_led_open != LED_OPEN_FALSE)
 161   1          {
 162   2              max7219_write(MAX7219_ADDR_SHUTDOWN, 0x00);//正常模式(掉电模式开)
 163   2              g_led_open = LED_OPEN_FALSE;
 164   2          }
 165   1      }
 166          
 167          uchar g_led_light = 0xff;
 168          void led_set_light(uchar n)
 169          {
 170   1          if(g_led_light != n)
 171   1          {
 172   2              g_led_light = n;
 173   2              n = ((n > 0x0f) ? 0x0f : n); //0-15
 174   2              max7219_write(MAX7219_ADDR_INTENSITY, n);
 175   2          }
 176   1      }
 177          
 178          void led_set_mirror(uchar mirror)
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 4   

 179          {
 180   1          g_led_mirror = (mirror ? 1 : 0);
 181   1      }
 182          
 183          uint8 led_get_mirror(void)
 184          {
 185   1          return g_led_mirror;
 186   1      }
 187          
 188          uchar led_mirror_segb(uchar segb)
 189          {
 190   1          uchar segbc = 0, i = 0;
 191   1          for(i=0; i<LED_SEGB_MAX; i++)
 192   1          {
 193   2              if(segb & (0x01 << i))
 194   2              {
 195   3                  segbc |= (0x01 << LED_SEGB_MIRROR[i]);
 196   3              }
 197   2          }
 198   1      
 199   1          return segbc;
 200   1      }
 201          
 202          void led_set_point(uchar pos, uchar seg, uchar col)
 203          {
 204   1          if((pos >= LED_POS_MAX) || (seg >= LED_SEGB_MAX))
 205   1          {
 206   2              return;
 207   2          }
 208   1      
 209   1          LED_MIRROR_POS(pos);
 210   1          LED_MIRROR_SEG(seg);
 211   1      
 212   1          if(col)
 213   1          {
 214   2              LED_DISP_MEM[pos] |= (uchar)(0x01 << seg);
 215   2          }
 216   1          else
 217   1          {
 218   2              LED_DISP_MEM[pos] &= (uchar)(~(0x01 << seg));
 219   2          }
 220   1      }
 221          
 222          uchar led_get_point(uchar pos, uchar seg)
 223          {
 224   1          uchar ret = 0;
 225   1      
 226   1          pos = ((pos >= LED_POS_MAX) ? (LED_POS_MAX - 1) : pos);
 227   1          seg = ((seg >= LED_SEGB_MAX) ? (LED_SEGB_MAX - 1) : seg);
 228   1      
 229   1          LED_MIRROR_POS(pos);
 230   1          LED_MIRROR_SEG(seg);
 231   1      
 232   1          ret = (LED_DISP_MEM[pos] & (uchar)(0x01 << seg));
 233   1          return ret;
 234   1      }
 235          
 236          void led_update(void)
 237          {
 238   1          uchar i = 0;
 239   1      
 240   1          static uint16 led_pos_flag0[LED_POS_MAX] = 0;
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 5   

 241   1          static uint16 led_pos_flag1[LED_POS_MAX] = 0;
 242   1      
 243   1          for(i = 0; i < LED_POS_MAX; i++)
 244   1          {
 245   2              if(LED_FLASH_TMR[i])
 246   2              {
 247   3                  if(led_pos_flag0[i] < LED_FLASH_TMR[i])
 248   3                  {
 249   4                      led_pos_flag0[i] += 1;
 250   4                  }
 251   3                  else
 252   3                  {
 253   4                      led_pos_flag0[i] = 0;
 254   4                      led_pos_flag1[i] = (led_pos_flag1[i] ? 0 : 1);
 255   4                  }
 256   3              }
 257   2              else
 258   2              {
 259   3                  led_pos_flag0[i] = 0;
 260   3                  led_pos_flag1[i] = 0;
 261   3              }
 262   2      
 263   2              if(led_pos_flag1[i])
 264   2              {
 265   3                  max7219_write(i + 1, LED_SEG_CODE[LED_SEG_NULL]);
 266   3              }
 267   2              else
 268   2              {
 269   3                  max7219_write(i + 1, LED_DISP_MEM[i]);
 270   3              }
 271   2          }
 272   1      }
 273          
 274          void led_clear(uchar dat)
 275          {
 276   1          uchar i = 0;
 277   1      
 278   1          for(i = 0; i < LED_POS_MAX; i++)
 279   1          {
 280   2              LED_DISP_MEM[i] = dat;
 281   2              LED_FLASH_TMR[i] = 0;
 282   2          }
 283   1      }
 284          
 285          void led_open_door(uint16 delay)
 286          {
 287   1          uchar i = 0, j = 0;
 288   1          for(i=0; i<LED_POS_MAX; i++)
 289   1          {
 290   2              for(j=0; j<LED_SEGB_MAX; j++)
 291   2              {
 292   3                  led_set_point(i, j, 1);
 293   3                  led_update();
 294   3                  delay_xms(delay);
 295   3              }
 296   2          }
 297   1      }
 298          
 299          void led_close_door(uint16 delay)
 300          {
 301   1          uchar i = 0, j = 0;
 302   1          for(i=0; i<LED_POS_MAX; i++)
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 6   

 303   1          {
 304   2              for(j=0; j<LED_SEGB_MAX; j++)
 305   2              {
 306   3                  led_set_point(LED_POS_MAX-1-i, LED_SEGB_MAX-1-j, 0);
 307   3                  led_update();
 308   3                  delay_xms(delay);
 309   3              }
 310   2          }
 311   1      }
 312          
 313          void led_init(void)
 314          {
 315   1          max7219_init();
 316   1      
 317   1          led_open();
 318   1          led_set_light(LED_MAX_LIGHT);
 319   1          led_set_mirror(0);
 320   1      
 321   1          led_clear(0);
 322   1          led_update();
 323   1      }
 324          
 325          uchar led_seg_cidx_get(char chr)
 326          {
 327   1          uchar idx = 0;
 328   1      
 329   1          if((chr >= '0') && (chr <= '9'))
 330   1          {
 331   2              idx = chr - '0' + LED_SEG_0;
 332   2          }
 333   1          else if((chr >= 'A') && (chr <= 'G'))
 334   1          {
 335   2              idx = chr - 'A' + LED_SEG_A;
 336   2          }
 337   1          else if((chr >= 'a') && (chr <= 'g'))
 338   1          {
 339   2              if(chr == 'c')
 340   2              {
 341   3                  idx = LED_SEG_CS;
 342   3              }
 343   2              else
 344   2              {
 345   3                  idx = chr - 'a' + LED_SEG_A;
 346   3              }
 347   2          }
 348   1          else if(chr == '-')
 349   1          {
 350   2              idx = LED_SEG_HL;
 351   2          }
 352   1          else if(chr == '_')
 353   1          {
 354   2              idx = LED_SEG_SD;
 355   2          }
 356   1          else if(chr == '[')
 357   1          {
 358   2              idx = LED_SEG_LSB;
 359   2          }
 360   1          else if(chr == ']')
 361   1          {
 362   2              idx = LED_SEG_RSB;
 363   2          }
 364   1          else if(chr == '{')
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 7   

 365   1          {
 366   2              idx = LED_SEG_BCG;
 367   2          }
 368   1          else if(chr == '}')
 369   1          {
 370   2              idx = LED_SEG_EFG;
 371   2          }
 372   1          else if(chr == 'H')
 373   1          {
 374   2              idx = LED_SEG_H;
 375   2          }
 376   1          else if(chr == 'h')
 377   1          {
 378   2              idx = LED_SEG_HS;
 379   2          }
 380   1          else if((chr == 'L') || (chr == 'l'))
 381   1          {
 382   2              idx = LED_SEG_L;
 383   2          }
 384   1          else if((chr == 'O') || (chr == 'o'))
 385   1          {
 386   2              idx = LED_SEG_O;
 387   2          }
 388   1          else if((chr == 'P') || (chr == 'p'))
 389   1          {
 390   2              idx = LED_SEG_P;
 391   2          }
 392   1          else if(chr == ' ')
 393   1          {
 394   2              idx = LED_SEG_NULL;
 395   2          }
 396   1      #if 0
                  else if((chr > 0) && (chr <  LED_SEG_MAX))
                  {
                      idx = LED_SEG_MIN + chr;
                  }
              #endif
 402   1          else
 403   1          {
 404   2              idx = LED_SEG_NULL;
 405   2          }
 406   1      
 407   1          return idx;
 408   1      }
 409          
 410          uchar led_seg_cpy2mem(uchar pos, uchar segc, uchar col, uchar dp)
 411          {
 412   1          uchar i = 0;
 413   1          if(pos >= LED_POS_MAX)
 414   1          {
 415   2              return RTN_ERR;
 416   2          }
 417   1      
 418   1          for(i = 0; i < LED_SEGB_MAX; i++)
 419   1          {
 420   2              if(segc & (0x01 << i))
 421   2              {
 422   3                  led_set_point(pos, i, col);
 423   3              }
 424   2              else
 425   2              {
 426   3                  led_set_point(pos, i, !col);
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 8   

 427   3              }
 428   2          }
 429   1      
 430   1          if(dp)
 431   1          {
 432   2              led_set_point(pos, LED_SEGB_DP, col);
 433   2          }
 434   1          else
 435   1          {
 436   2              led_set_point(pos, LED_SEGB_DP, !col);
 437   2          }
 438   1      
 439   1          return RTN_OK;
 440   1      }
 441          
 442          uchar led_putc_dp(uchar pos, char chr, uchar col, uchar dp)
 443          {
 444   1          uchar segidx = 0;
 445   1          if(pos >= LED_POS_MAX)
 446   1          {
 447   2              return RTN_ERR;
 448   2          }
 449   1      
 450   1          segidx = led_seg_cidx_get(chr);
 451   1          return led_seg_cpy2mem(pos, LED_SEG_CODE[segidx], col, dp);
 452   1      }
 453          
 454          uchar led_putc(uchar pos, char chr, uchar col)
 455          {
 456   1          return led_putc_dp(pos, chr, col, 0);
 457   1      }
 458          
 459          uchar led_puts_dp(uchar pos, const uchar *chs, uchar col, uchar dp)
 460          {
 461   1          uchar i = 0, p = pos;
 462   1          if((pos >= LED_POS_MAX) || (chs == NULL))
 463   1          {
 464   2              return RTN_ERR;
 465   2          }
 466   1          while(*chs)
 467   1          {
 468   2              if(led_putc_dp(p, *chs, col, dp) == RTN_OK)
 469   2              {
 470   3                  p++;
 471   3                  if(p >= LED_POS_MAX)
 472   3                  {
 473   4                      break;
 474   4                  }
 475   3              }
 476   2              chs++;
 477   2          }
 478   1      
 479   1          return RTN_OK;
 480   1      }
 481          
 482          uchar led_puts(uchar pos, const uchar *chs, uchar col)
 483          {
 484   1          return led_puts_dp(pos, chs, col, 0);
 485   1      }
 486          
 487          //直接显示一个段码
 488          uchar led_putb(uchar pos, uchar segb, uchar col, uchar andor)
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 9   

 489          {
 490   1          uchar i = 0;
 491   1          if(pos >= LED_POS_MAX)
 492   1          {
 493   2              return RTN_ERR;
 494   2          }
 495   1      
 496   1          for(i=0; i<LED_SEGB_MAX; i++)
 497   1          {        
 498   2              if(andor)
 499   2              {
 500   3                  if(segb & (0x01 << i))
 501   3                  {
 502   4                      led_set_point(pos, i, col);
 503   4                  }
 504   3              }
 505   2              else
 506   2              {
 507   3                  if(segb & (0x01 << i))
 508   3                  {
 509   4                      led_set_point(pos, i, col);
 510   4                  }
 511   3                  else
 512   3                  {
 513   4                      led_set_point(pos, i, !col);
 514   4                  }
 515   3              }
 516   2          }
 517   1      
 518   1          
 519   1      
 520   1          return RTN_OK;
 521   1      }
 522          
 523          uchar led_putbs(uchar pos, uchar *segb, uchar len, uchar col, uchar andor)
 524          {
 525   1          uchar i = 0;
 526   1          if((pos >= LED_POS_MAX) || ((pos + len) > LED_POS_MAX) || (segb == NULL))
 527   1          {
 528   2              return RTN_ERR;
 529   2          }
 530   1      
 531   1      
 532   1          for(i = pos; i < len; i++)
 533   1          {
 534   2              led_putb(i, segb[i - pos], col, andor);
 535   2          }
 536   1      
 537   1          return RTN_OK;
 538   1      }
 539          
 540          //根据段码索引显示
 541          uchar led_puti(uchar pos, uchar segi, uchar col)
 542          {
 543   1          uchar segb = 0;
 544   1      
 545   1          if((pos >= LED_POS_MAX) || (segi >= LED_SEG_MAX))
 546   1          {
 547   2              return RTN_ERR;
 548   2          }
 549   1      
 550   1          segb = LED_SEG_CODE[segi];
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 10  

 551   1      
 552   1          //segb = led_mirror_segb(segb);
 553   1      
 554   1          led_putb(pos, segb, col, 0);
 555   1      
 556   1          return RTN_OK;
 557   1      }
 558          
 559          uchar led_putis(uchar pos, uchar *segi, uchar len, uchar col)
 560          {
 561   1          uchar i = 0;
 562   1          if((pos >= LED_POS_MAX) || ((pos + len) > LED_POS_MAX) || (segi == NULL))
 563   1          {
 564   2              return RTN_ERR;
 565   2          }
 566   1      
 567   1      
 568   1          for(i = pos; i < len; i++)
 569   1          {
 570   2              led_puti(i, segi[i - pos], col);
 571   2          }
 572   1      
 573   1          return RTN_OK;
 574   1      }
 575          
 576          uchar led_set_flashc(uchar pos, uint16 flashtmr)
 577          {
 578   1          if(pos >= LED_POS_MAX)
 579   1          {
 580   2              return RTN_ERR;
 581   2          }
 582   1      
 583   1          LED_MIRROR_POS(pos);
 584   1      
 585   1          LED_FLASH_TMR[pos] = flashtmr;
 586   1          
 587   1          return RTN_OK;
 588   1      }
 589          
 590          uchar led_set_flashs(uchar pos, uchar len, uint16 flashtmr)
 591          {
 592   1          uchar i = 0;
 593   1          if((pos >= LED_POS_MAX) || (len > LED_POS_MAX))
 594   1          {
 595   2              return RTN_ERR;
 596   2          }
 597   1      
 598   1          len += pos;
 599   1      
 600   1          len = ((len > LED_POS_MAX) ? LED_POS_MAX : len);
 601   1      
 602   1          for(i = pos; i < len; i++)
 603   1          {
 604   2              led_set_flashc(i, flashtmr);
 605   2          }
 606   1          
 607   1          return RTN_OK;
 608   1      }
 609          


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.59.0.0   DRV_LED                                                           05/06/2019 23:08:39 PAGE 11  

   CODE SIZE        =   1686    ----
   CONSTANT SIZE    =     47    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31      50
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
